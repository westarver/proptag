package proptag

import (
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode/utf8"

	"github.com/westarver/helper"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// regex patterns to locate potential variables to process
const (
	LPar      = `\050`
	RPar      = `\051`
	LBrk      = `\133`
	RBrk      = `\135`
	LBrc      = `\123`
	RBrc      = `\125`
	Aster     = `\052`
	WS0       = `[\t ]*`
	WS1       = `[\t ]+`
	IdentList = IdentPat + WS0 + `(,` + WS1 + IdentPat + `)*`
	TParam    = `(` + LBrk + `(_?[A-Za-z_]+[0-9]*[ ,]*)+` + RBrk + `)?`
	IdentPat  = `_?[A-Za-z_]+[0-9]*`
	TypePat   = Aster + `?` + IdentPat + WS0 + TParam
	LinePat   = `<p((g|G)?` + Aster + `?(s|S)?)?` + Aster + `?/>`
	OpenPat   = `<p((g|G)?` + Aster + `?(s|S)?` + Aster + `?)?>`
	ClosePat  = `</prop>`
	VarPat    = WS0 + `var` + WS1 + IdentPat + WS1 + TypePat
	VarBlkPat = WS0 + `var` + WS0 + LPar
	StructPat = WS0 + `type` + WS1 + IdentPat + WS0 + TParam + WS1 + `struct` + WS0 + `{`
	InBlkPat  = WS0 + `^(var)` + IdentPat + WS1 + TypePat
)

type tagFlag uint32

const (
	hasget tagFlag = (1 << iota)
	hasset
	callset
	callget
	getref
	setref
	endtag
	badtag
)

type scanfunc func(*goSource) scanfunc

type goSource struct {
	text       []string
	scanning   string
	propFile   strings.Builder
	pkg        string
	insource   string
	scanErrors []error
	line       int
	linepat    *regexp.Regexp
	openpat    *regexp.Regexp
	closepat   *regexp.Regexp
	varpat     *regexp.Regexp
	varblkpat  *regexp.Regexp
	structpat  *regexp.Regexp
	inblkpat   *regexp.Regexp
}

//─────────────┤ doGenerate ├─────────────

func doGenerate(inp []byte, in string /*for error messeges*/, out *os.File) []error {
	linepat, _ := regexp.Compile(LinePat)
	openpat, _ := regexp.Compile(OpenPat)
	closepat, _ := regexp.Compile(ClosePat)
	varpat, _ := regexp.Compile(VarPat)
	varblkpat, _ := regexp.Compile(VarBlkPat)
	structpat, _ := regexp.Compile(StructPat)
	inblkpat, _ := regexp.Compile(InBlkPat)

	lines := strings.Split(string(inp), "\n")
	src := goSource{
		text:       lines,
		scanning:   "",
		propFile:   strings.Builder{},
		pkg:        "",
		insource:   in,
		scanErrors: nil,
		line:       0,
		linepat:    linepat,
		openpat:    openpat,
		closepat:   closepat,
		varpat:     varpat,
		varblkpat:  varblkpat,
		structpat:  structpat,
		inblkpat:   inblkpat,
	}

	scanf := scanPkg(&src)
	for {
		if scanf == nil {
			break
		}
		scanf = scanf(&src)
	}

	if out != nil {
		m, _ := fmt.Fprintln(out, "//File generated by prop-tag")
		n, _ := fmt.Fprintln(out, src.propFile.String())
		fmt.Fprintf(os.Stdout, "wrote %d bytes to %s\n", m+n, out.Name())
	}

	return src.scanErrors
}

func (s *goSource) getNextLine() (string, error) {
	if s.line >= len(s.text) {
		return "", io.EOF
	}
	line := s.text[s.line]
	s.advance()
	s.scanning = line
	return line, nil
}

func (s *goSource) advance() {
	s.line++
}

func (s *goSource) current() string {
	return s.scanning
}

func (s *goSource) setError(err error) {
	s.scanErrors = append(s.scanErrors, err)
}

//─────────────┤ getTagSpec ├─────────────

func getTagSpec(line string) tagFlag {
	i := strings.Index(line, "</prop>")
	if i >= 0 {
		return endtag
	}
	j := strings.LastIndex(line, "<")
	k := strings.LastIndex(line, ">")
	if j == -1 || k == -1 || k < j {
		return badtag
	}
	tag := line[j+1 : k]
	if len(tag) < 2 {
		return badtag
	}
	if tag[0] != 'p' {
		return badtag
	}

	var ret tagFlag
	switch tag[1] {
	case 'g':
		ret |= hasget
	case 'G':
		ret |= hasget
		ret |= callget
	case 's':
		ret |= hasset
	case 'S':
		ret |= hasset
		ret |= callset
	case '/':
		return ret
	default:
		return badtag
	}
	if len(tag) < 3 {
		return ret
	}

	switch tag[2] {
	case 'g', 'G':
		return badtag
	case 's':
		if tag[1] == 's' || tag[1] == 'S' {
			return badtag
		}
		ret |= hasset
	case 'S':
		if tag[1] == 's' || tag[1] == 'S' {
			return badtag
		}
		ret |= hasset
		ret |= callset
	case '*':
		if tag[1] == 'g' || tag[1] == 'G' {
			ret |= getref
		}
		if tag[1] == 's' || tag[1] == 'S' {
			ret |= setref
		}
	case '/':
		return ret
	default:
		return badtag
	}
	if len(tag) < 4 {
		return ret
	}

	switch tag[3] {
	case 'g':
		ret |= hasget
	case 'G':
		ret |= hasget
		ret |= callget
	case 's':
		ret |= hasset
	case 'S':
		ret |= hasset
		ret |= callset
	case '/':
		return ret
	case '*':
		if tag[2] == 'g' || tag[2] == 'G' {
			ret |= getref
		}
		if tag[2] == 's' || tag[2] == 'S' {
			ret |= setref
		}
	default:
		return badtag
	}
	if len(tag) < 5 {
		return ret
	}

	switch tag[4] {
	case '/':
		return ret
	case '*':
		if tag[3] == 'g' || tag[3] == 'G' {
			ret |= getref
		}
		if tag[3] == 's' || tag[3] == 'S' {
			ret |= setref
		}
	default:
		return badtag
	}
	return ret
}

//─────────────┤ doMakeGetter ├─────────────

func doMakeGetter(s *goSource, r *regexp.Regexp, line string, callg, gref bool) error {
	toks := r.FindAllString(line, -1)
	if toks == nil {
		return fmt.Errorf("file %s line %d does not contain a variable declaration", filepath.Base(s.insource), s.line)
	}
	tox := helper.RemoveDupChar(toks[0], ' ', 1)
	tokens := strings.Split(tox, " ")
	if len(tokens) < 3 {
		return fmt.Errorf("file %s line %d malformed variable declaration - no type given", filepath.Base(s.insource), s.line)
	}
	var (
		comment = "returns the value of"
		ptr     = ""
		ret     = ""
		ref     = ""
	)

	if gref {
		comment = "returns a pointer to"
		ptr = "*"
		ref = "&"
	}
	ret = tokens[1]
	if callg {
		ret = ret + ".Get()"
	} else {
		ret = ref + ret
	}
	tcaser := cases.Title(language.AmericanEnglish)
	title := tcaser.String(tokens[1])
	fn := "// " + title + " " + comment + " the unexported variable " + tokens[1]
	fn += "\n func " + title + "() " + ptr + tokens[2] + " {"
	fn += "\n\treturn " + ret
	fn += "\n}\n\n"
	s.propFile.WriteString(fn)
	return nil
}

//─────────────┤ doMethodGetter ├─────────────

func doMethodGetter(s *goSource, r *regexp.Regexp, struc string, line string, callg, gref bool) error {
	toks := r.FindAllString(line, -1)
	if toks == nil {
		return fmt.Errorf("file %s line %d does not contain a field declaration", filepath.Base(s.insource), s.line)
	}
	tox := helper.RemoveDupChar(toks[0], ' ', 1)
	tokens := strings.Split(tox, " ")
	if len(tokens) < 3 {
		return fmt.Errorf("file %s line %d malformed field declaration in struct %s", filepath.Base(s.insource), s.line, struc)
	}
	var (
		comment = "returns the value of"
		ptr     = ""
		ret     = ""
		ref     = ""
	)

	if gref {
		comment = "returns a pointer to"
		ptr = "*"
		ref = "&"
	}
	ret = tokens[1]
	if callg {
		ret = ret + ".Get()"
		ref = ""
	}
	tcaser := cases.Title(language.AmericanEnglish)
	title := tcaser.String(tokens[1])
	rcvr, _ := utf8.DecodeRuneInString(struc)
	fn := "// (*" + struc + ") " + title + " " + comment + " the unexported struct field " + tokens[1]
	fn += "\n func (" + string(rcvr) + " *" + struc + ") " + title + "() " + ptr + tokens[2] + " {"
	fn += "\n\treturn " + ref + string(rcvr) + "." + ret
	fn += "\n}\n\n"
	s.propFile.WriteString(fn)
	return nil
}

//─────────────┤ doMakeSetter ├─────────────

func doMakeSetter(s *goSource, r *regexp.Regexp, line string, calls, sref bool) error {
	toks := r.FindAllString(line, -1)
	if toks == nil {
		return fmt.Errorf("file %s line %d does not contain a variable declaration", filepath.Base(s.insource), s.line)
	}
	tox := helper.RemoveDupChar(toks[0], ' ', 1)
	tokens := strings.Split(tox, " ")
	if len(tokens) < 3 {
		return fmt.Errorf("file %s line %d malformed variable declaration - no type given", filepath.Base(s.insource), s.line)
	}
	var (
		comment = "assigns the value of val to"
		ptr     = ""
		set     = ""
	)

	if sref {
		comment = "assigns a pointer to val to"
		ptr = "*"
	}
	set = tokens[1] + " = val"
	if calls {
		set = tokens[1] + ".Set(val)"
	}
	fn := "// Set" + tokens[1] + " " + comment + " the unexported variable " + tokens[1]
	fn += "\n func Set" + tokens[1] + "(val " + ptr + tokens[2] + ") {"
	fn += "\n\t" + set
	fn += "\n}\n\n"
	s.propFile.WriteString(fn)
	return nil
}

//─────────────┤ doMethodSetter ├─────────────

func doMethodSetter(s *goSource, r *regexp.Regexp, struc string, line string, calls, sref bool) error {
	toks := r.FindAllString(line, -1)
	if toks == nil {
		return fmt.Errorf("file %s line %d does not contain a field declaration", filepath.Base(s.insource), s.line)
	}
	tox := helper.RemoveDupChar(toks[0], ' ', 1)
	tokens := strings.Split(tox, " ")
	if len(tokens) < 3 {
		return fmt.Errorf("file %s line %d malformed field declaration in struct %s", filepath.Base(s.insource), s.line, struc)
	}

	var (
		comment = "assigns the value of val to"
		ptr     = ""
		set     = ""
	)

	if sref {
		comment = "assigns a pointer to val to"
		ptr = "*"
	}

	rcvr, _ := utf8.DecodeRuneInString(struc)
	set = string(rcvr) + "." + tokens[1] + " = " + ptr + "val"
	if calls {
		set = string(rcvr) + "." + tokens[1] + ".Set(val)"
	}

	fn := "// (*" + struc + ") Set" + tokens[1] + " " + comment + " the unexported struct field " + tokens[1]
	fn += "\n func (" + string(rcvr) + " *" + struc + ") " + "Set" + tokens[1] + "(val " + ptr + tokens[2] + ") {"
	fn += "\n\t" + set
	fn += "\n}\n\n"
	s.propFile.WriteString(fn)
	return nil
}

//─────────────┤ doVar ├─────────────

func doVar(s *goSource, line string, flag tagFlag) error {
	var callg, calls, gref, sref bool
	if flag&hasget != 0 {
		if flag&callget != 0 {
			callg = true
		}
		if flag&getref != 0 {
			gref = true
		}
		if err := doMakeGetter(s, s.varpat, line, callg, gref); err != nil {
			return err
		}
	}
	if flag&hasset != 0 {
		if flag&callset != 0 {
			calls = true
		}
		if flag&setref != 0 {
			sref = true
		}
		if err := doMakeSetter(s, s.varpat, line, calls, sref); err != nil {
			return err
		}
	}
	return nil
}

//─────────────┤ scanPkg ├─────────────

func scanPkg(s *goSource) scanfunc {
	for {
		line, err := s.getNextLine()
		if errors.Is(err, io.EOF) {
			break
		}
		line = strings.TrimLeft(line, "\t ")
		if strings.HasPrefix(line, CommentString) {
			continue
		}
		if strings.HasPrefix(line, "package") {
			p := strings.Split(line, " ")
			if len(p) >= 2 {
				s.pkg = p[1]
				s.propFile.WriteString("package " + s.pkg + "\n\n")
			}
			return scanText
		}
	}
	s.setError(fmt.Errorf("file %s package keyword and name not found", filepath.Base(s.insource)))
	return nil
}

//─────────────┤ scanText ├─────────────

func scanText(s *goSource) scanfunc {

	for {
		line, err := s.getNextLine()
		if errors.Is(err, io.EOF) {
			break
		}
		line = strings.TrimLeft(line, "\t ")
		if s.varpat.MatchString(line) {
			return scanVar
		}
		if s.varblkpat.MatchString(line) {
			return scanVarBlk
		}
		if s.structpat.MatchString(line) {
			return scanStruct
		}
		if s.openpat.MatchString(line) {
			//			trace.Trace("matched openpat", s.openpat.String(), " with ", line)
			return scanPropBlk
		}
		if s.closepat.MatchString(line) {
			s.setError(fmt.Errorf("file %s line %d misplaced </prop> tag", filepath.Base(s.insource), s.line))
		}
	}
	return nil
}

//─────────────┤ scanVar ├─────────────

func scanVar(s *goSource) scanfunc {
	line := s.current()
	flag := getTagSpec(line)
	err := doVar(s, line, flag)
	if err != nil {
		s.setError(err)
	}
	return scanText
}

//─────────────┤ scanVarBlk ├──────────────

func scanVarBlk(s *goSource) scanfunc {
	var err error
	line := s.current()
	// search for the end of the var block
	var blktext = s.text[s.line:]
	var blkend = s.line
	var prn = 1
	for _, l := range blktext {
		for _, r := range l {
			if r == '(' {
				prn++
			}
			if r == ')' {
				prn--
			}
		}
		blkend++
		if prn == 0 {
			break
		}
		if prn < 0 {
			s.setError(fmt.Errorf("file %s line %d mismatched parentheses", filepath.Base(s.insource), blkend))
			return nil
		}
	}
	for {
		if s.openpat.MatchString(line) {
			//trace.Trace("matched openpat", s.openpat.String(), " with ", line)
			_ = scanPropBlk(s)
		}
		line = "var " + line
		if s.varpat.MatchString(line) {
			flag := getTagSpec(line)
			_ = doVar(s, line, flag)
		}

		line, err = s.getNextLine()
		if errors.Is(err, io.EOF) {
			return nil
		}
		if s.line == blkend {
			break
		}
	}
	return scanText
}

//─────────────┤ scanPropBlk ├─────────────

func scanPropBlk(s *goSource) scanfunc {
	var err error
	line := s.current()
	toks := s.openpat.FindAllString(line, -1)
	tox := helper.RemoveDupChar(toks[0], ' ', 1)
	tokens := strings.Split(tox, " ")
	blktag := tokens[len(tokens)-1]
	for {
		line = strings.TrimLeft(line, "\t ")
		line = line + "// " + blktag

		if !strings.HasPrefix(line, "var") {
			line = "var " + line
		}
		if s.varpat.MatchString(line) {
			flag := getTagSpec(line)
			_ = doVar(s, line, flag)
		}

		line, err = s.getNextLine()
		if errors.Is(err, io.EOF) {
			return nil
		}
		if s.closepat.MatchString(line) {
			break
		}
	}
	return scanText
}

//─────────────┤ scanStruct ├──────────────

func scanStruct(s *goSource) scanfunc {
	// search for the end of the struct definition
	var brc = 1
	var strtext = s.text[s.line:]
	var strend = s.line
	for _, l := range strtext {
		for _, r := range l {
			if r == '{' {
				brc++
			}
			if r == '}' {
				brc--
			}
		}
		strend++
		if brc == 0 {
			break
		}
		if brc < 0 {
			s.setError(fmt.Errorf("file %s line %d mismatched braces", filepath.Base(s.insource), strend))
			return nil
		}
	}

	// iterate each line until end
	var callg, calls, gref, sref, propblk bool
	var err error
	line := s.current()
	toks := s.structpat.FindAllString(line, -1)
	tokens := helper.RemoveDupChar(toks[0], ' ', 1)
	struc := splitType(tokens)
	var blktag string
	for {
		line, err = s.getNextLine()
		if errors.Is(err, io.EOF) {
			return nil
		}
		if s.line >= strend {
			break
		}
		if len(line) == 0 {
			continue
		}
		if s.openpat.MatchString(line) {
			propblk = true
			i := s.openpat.FindStringIndex(line)
			blktag = line[i[0]:i[1]-1] + "/>"
			continue
		}
		if s.closepat.MatchString(line) {
			if propblk {
				propblk = false
				blktag = ""
				//_, _ = s.getNextLine()
				continue
			}
			s.setError(fmt.Errorf("file %s line %d misplaced </prop> tag", filepath.Base(s.insource), s.line))
		}
		line = "var " + strings.TrimLeft(line, " \t")
		if propblk {
			line = line + "//" + blktag
		}

		if s.linepat.MatchString(line) {
			flag := getTagSpec(line)
			if flag&hasget != 0 {
				if flag&callget != 0 {
					callg = true
				}
				if flag&getref != 0 {
					gref = true
				}
				if err := doMethodGetter(s, s.varpat, struc, strings.TrimLeft(line, "\t "), callg, gref); err != nil {
					s.setError(err)
				}
			}
			if flag&hasset != 0 {
				if flag&callset != 0 {
					calls = true
				}
				if flag&setref != 0 {
					sref = true
				}
				if err := doMethodSetter(s, s.varpat, struc, strings.TrimLeft(line, "\t "), calls, sref); err != nil {
					s.setError(err)
				}
			}
		}
		callg = false
		calls = false
		gref = false
		sref = false
	}
	return scanText
}

//─────────────┤ splitType ├─────────────

func splitType(line string) string {
	i := strings.Index(line, "type")
	if i == -1 {
		return ""
	}
	line = line[i+5:]
	i = strings.Index(line, "struct")
	if i == -1 {
		return ""
	}
	typ := strings.Trim(line[:i], " \t")

	i = strings.Index(typ, "[")
	if i == -1 {
		return typ
	}
	j := strings.Index(typ, "]")
	if j == -1 {
		return ""
	}
	t := typ[:i]
	tparam := strings.Split(typ[i:j], " ")
	return t + tparam[0] + "]"
}
